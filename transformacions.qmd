---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Recodificacions
```{r echo = F, message=F}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE,
                      message = FALSE)
library(pacman)
p_load(tidyverse, readxl, janitor, foreign, haven, knitr)
strings <- tribble(~iso3c, ~country, ~currency, ~continent, ~region,
        "CMR", "Cameroon", "CFA Franc BEAC", "Africa", "Sub-Saharan Africa",
        "COL", "Colombia", "Colombian Peso", "Americas", "Latin America & Caribbean",
        "CUB", "Cuba", "Cuban Peso", "Americas", "Latin America & Caribbean",
        "FRA", "France", "Euro", "Europe", "Europe & Central Asia",
        "LSO", "Lesotho", "Loti", "Africa", "Sub-Saharan Africa",
        "QAT", "Qatar", "Qatari Rial", "Asia", "Middle East & North Africa",
        "TWN", "Taiwan", "New Taiwan Dollar", "Asia", "East Asia & Pacific",
        "TTO", "Trinidad & Tobago", "Trinidad and Tobago Dollar", "Americas", "Latin America & Caribbean")
ords <- tibble(donor = c("US-MCC", "Canada-GAC", "Germany-BMZ-GIZ", "Korea-KOICA", "Australia-DFAT", "Spain-AECID", 
                         "Saudi Arabia-KSRelief", "Norway-MFA", "China-MOFCOM", "Turkey-TIKA"),
               ati = factor(c("Very Good", "Good", "Good", "Good", "Good", "Fair",
                              "Poor", "Poor", "Very Poor", "Very Poor"),
                            ordered = TRUE,
                            levels = c("Very Poor", "Poor", "Fair", "Good", "Very Good")),
               regime_type = factor(c("Flawed Democracy", "Full Democracy", "Full Democracy", "Full Democracy", "Full Democracy", 
                                      "Flawed Democracy", "Authoritarian", "Full Democracy", "Authoritarian", "Hybrid Regime"), 
                                    ordered = TRUE,
                                    levels = c("Authoritarian", "Hybrid Regime", "Flawed Democracy", "Full Democracy")))
ratio <- tibble(country = c("USA", "UKG", "FRN", "GMY", "ITA", "RUS", "JPN"),
                milex = c(980000, 7895671, 1023651, 12000000, 669412, 5984123, 1699970),
                milper = c(334, 394, 581, 2750, 581, 1789, 957),
                tpop = c(131028, 47762, 41900, 79798, 44020, 170317, 71380),
                cinc = c(0.182, 0.0997, 0.0396, 0.178, 0.0270, 0.138, 0.0591))
polity <- tibble(country = c("United States", "Bolivia", "Australia", "Azerbaijan",
                             "USSR", "Timor Leste", "Eritrea", "Qatar", "Gambia"),
                 year = c(1776, 1825, 1901, 1991, 1922, 2002, 1993, 1971, 1965),
                 polity2 = c(0, -3, 10, -3, -7, 6, -6, -10, 8))
mid_recod <- read_csv("files/mid_recod.csv")
relig_recod <- read_csv("files/relig_recod.csv")
wb_recod <- read_csv("files/wb_recod.csv")
wvs_recod <- read_csv("files/wvs_recod.csv")
```

## Introducció

En moltes ocasions ens trobarem amb variables que necessiten ser recodificades. Recodificar una variable significa modificar els seus valors de manera parcial o total, fins al punt d'arribar a canviar el tipus de vector o de variable. Aquestes transformacions acostumen a anar en sentit invers a com les hem estudiat. És a dir, sovint recodificarem una variable de ràtio per convertir-la en una variable ordinal, però difícilment podrem recodificar una variable nominal o ordinal en una de ràtio. Això és degut a que les variables categòriques tenen menys informació que les numèriques. Per exemple, amb una categòrica podem saber solament si un país és "Ric" o "Pobre", però amb aquesta informació és impossible transformar els seus valors a una xifra numèrica concreta. En canvi, a la inversa ens resulta més fàcil: si sabem que un país té 15.000 dòlars per càpita, fàcilment podem transformar aquesta xifra a "Ric" o "Pobre" en base a algun criteri concret.

Un resum del tipus de recodificacions que podem fer el trobem a la @tbl-recoding. A la primera columna veiem la variable de destí a la que ho volem recodificar i a la segona columna la funció que utilitzarem per fer la recodificació.  


| Destí      | Funció                                          |
|------------|-------------------------------------------------|
| Binària    | `if_else()`                                     |
| Categòrica | `case_when()`                                   |
| Ordinal    | `factor()`                                      |
| Qualsevol  | `recode()`                                      |
| Altres     | `as.numeric()`, `as.character()`, `as.Date()`, etc. |

: Variable de destí i funció que es necessita {#tbl-recoding}

A l'hora de recodificar variables, els vectors lògics tenen una importància capital. Anteriorment ja havíem comentat que els vectors lògics eren molt importants, però en el darrer apartat hem vist que no estan explícitament associats a cap variable. Així doncs, de què ens serveix un vector lògic? Els vectors lògics són principalment eines operacionals. Això significa que ens serviran per crear les condicions que permetin canviar d'un tipus de variable a una altra o per filtrar les observacions d'un marc de dades. I per explotar les seves potencialitats necessitarem conèixer els operadors Booleans.

Els **operadors Booleans** o relacionals ens permeten fer combinacions de valors de forma lògica. Per comprendre'n el seu funcionament, es recomana veure primer el vídeo de la dreta. En segon lloc, aplicarem els tres operadors Booleans (AND, OR i NOT) al marc de dades `ctr_pov`, que veiem sencer a la @tbl-pov del marge lateral.

::: {.column-margin}
::: {.callout-note}
## Operadors Booleans
{{< video https://youtu.be/6PpQS-YLWDQ >}}
:::
:::

- L'operador **AND** (`&`) retorna TRUE només si es compleixen totes les condicions.
- L'operador **OR** (`|`) retorna TRUE si es compleix una de les condicions.
- L'operador **NOT** (`!`) retorna el contrari de la condició.

```{r echo = F, eval = T}
#| tbl-column: margin
#| tbl-cap: Llindars de pobresa
#| label: tbl-pov
tibble(country = c("Armenia", "Austria", "Benin", "Bolivia",
                              "Brazil", "Colombia", "El Salvador",
                              "Ethiopia", "Honduras", "Indonesia"),
                  continent = c("FSU", "EUR", "AFR", "AME", "AME", "AME", 
                                "AME", "AFR", "AME", "ASI"),
                  poverty = c(1.90, 0.7, 49.6, 6.4, 3.4, 4.5, 
                              1.9, 26.7, 16.2, 7.2)) |> 
  kable()
```


```{r}
ctr_pov <- tibble(country = c("Armenia", "Austria", "Benin", "Bolivia",
                              "Brazil", "Colombia", "El Salvador",
                              "Ethiopia", "Honduras", "Indonesia"),
                  continent = c("ASI", "EUR", "AFR", "AME", "AME", "AME", 
                                "AME", "AFR", "AME", "ASI"),
                  poverty = c(1.90, 0.7, 49.6, 6.4, 3.4, 4.5, 
                              1.9, 26.7, 16.2, 7.2))
```

Combinant els operadors AND, OR i NOT podem aconseguir que R ens retorni com a TRUE i com a FALSE una combinació de diverses variables. A la @fig-booleans del lateral veiem algunes de les possibles combinacions, prenent com a variable `x` la rodona de l'esquerra i com a variable `y` la de la dreta. A continuació posem alguns exemples de combinacions. Fixeu-vos que aquestes operacions Booleanes ens retornen un vector lògic indicant quins valors compleixen (TRUE) les condicions que hem establert i quins valors no les compleixen (FALSE). Com veurem, podem aprofitar els TRUE per crear noves variables. És important comentar que es poden encadenar combinacions de tantes variables com es vulgui.

```{r echo = FALSE}
#| fig-cap: Combinacions d'operadors Booleans
#| label: fig-booleans
#| fig-column: margin
knitr::include_graphics("img/booleans.png")
```



::: {.panel-tabset}

## AND
Països africans i (AND) llindar de pobresa inferior a 30 dòlars. 
```{r}
ctr_pov$continent == "AFR" & ctr_pov$poverty > 30
```

Països africans o americans i (AND) que no (NOT) sigui Honduras. 
```{r}
ctr_pov$continent %in% c("AFR", "AME") & !ctr_pov$country == "Honduras" 
```

Països que no (NOT) siguin africans i (AND) que tinguin el llindar de pobresa inferior als 10 dòlars 
```{r}
!ctr_pov$continent == "AFR" & ctr_pov$poverty < 10
```



## OR

Països americans o (OR) llindar de pobresa inferior a 30 dòlars. 
```{r}
ctr_pov$continent == "AME" | ctr_pov$poverty > 30
```

Països africans o asiàtics o (OR) que no (NOT) tinguin el llindar de pobresa inferior als 10 dòlars.
```{r}
ctr_pov$continent %in% c("AFR", "AME") | !ctr_pov$poverty < 10
```

Països que no (NOT) siguin africans o (OR) que tinguin el llindar de pobresa inferior als 10 dòlars 
```{r}
!ctr_pov$continent == "AFR" | ctr_pov$poverty < 10
```

Val a dir que, abans d'utilitzar OR i NOT, sempre trobarem combinacions més senzilles per aconseguir el mateix resultat.
:::





## A variable binària

Qualsevol variable es pot recodificar en binària. Una variable numèrica que inclogui, per exemple, l'alçada de diferents persones, es podria recodificar en "Alt" i "Baix" si establim un llindar determinat que separi les dues categories. També es podria fer el mateix amb una variable nominal que descrivís el color del cabell de varis individus. Podríem crear una nova variable binària que tingués només dues categories: "Vermell" i "Altres".

Per dicotomitzar qualsevol variable, la funció més adequada és `if_else()` del paquet `dplyr`. En aquesta funció, situarem com a primer argument el resultat d'una operació lògica, com a segon argument el valor que prendrà la nova variable si el resultat de l'operació és certa, i com a tercer argument el valor que prendrà la nova variable si el resultat de l'operació és falsa.

```
if_else(operació lògica, TRUE, FALSE)
```

Posarem tres exemples per veure la funció `if_else()` en acció:  

::: {.panel-tabset .column-body-outset}
## Binària categòrica

El marc de dades `strings` conté la variable `continent`, que és categòrica. Per dicotomitzar-la crearem una condició lògica que ens identifiqui les observacions que són del continent americà. Quan és cert, li direm `"Americas"` i quan és fals, li direm `"Others"`. 

```{r}
strings$continent <- if_else(strings$continent == "Americas", "Americas", "Others")
strings
```

## Binària numèrica

El resultat de la binarització també pot ser numèric. A continuació recodifiquem l'escala ordinal de l'índex de democràcia de *The Economist* en 1 si és democràcia i 0 si no ho és. En el primer argument d'`if_else()` hem utilitzat la funció `str_detect()` del paquet `stringr` perquè marqui com a TRUE tots aquells valors del vector `ords$regime_type` que continguin `"Democracy"` (això inclou tant `Full Democracy` com `Flawed Democracy`). Amb això creem la nova variable `dem`.

```{r}
ords$dem <- if_else(str_detect(ords$regime_type, "Democracy"), 1, 0)
ords
```



## Combinació de variables

Amb els operadors Booleans podem crear una classificació que ens marqui els països amb més potencial militar del marc de dades `ratio` a partir d'establir una sèrie de condicions lògiques en diverses variables. Indicarem que un país és `"Powerful"` si té una despesa militar superior al milió de dòlars, un personal militar superior a 500.000 i una població superior als 70 milions d'habitants. Per introduir correctament les magnituds, cal consultar el llibre de codis de NMC.

```{r}
ratio$power <- if_else(ratio$milex > 1000000 & ratio$milper > 500 &
                       ratio$tpop > 70000,
                       "Powerful", "Powerless")
ratio
```

:::


## A variable categòrica 

Hi ha principalment dos motius pels quals voldrem recodificar una variable a categòrica. Tornant a l'exemple de l'alçada, podríem convertir diferents valors numèrics en tres categories: "Alt", "Mitjà", "Baix". O podríem recodificar una variable categòrica de forma que tingui menys categories. Per exemple, si tenim cinc religions ("Cristiana", "Protestant", "Islàmica", "Budista" i "Hindú"), podem voler recodificar les categories de manera que les dues primeres passin a dir-se "Catòlica". 

La funció adequada per fer aquest tipus de recodificacions és `case_when()`. La funció consta de tants arguments com categories vulguem crear i tots els arguments tenen la mateixa estructura, excepte l'últim. A cada argument situarem primer la condició lògica, seguit del símbol `~` i del nom que prendran tots els valors que compleixin aquesta condició. En l'últim argument indicarem `TRUE` enlloc d'una condició lògica, ho seguirem amb el símbol `~` i el nom de l'última categoria.


```
case_when(condició lògica ~ "C1"
          condició lògica ~ "C2",
          condició lògica ~ "C3",
          ...,
          TRUE ~ "CN")
```

És important tenir en compte que, a cada argument, `case_when()` va retirant els valors que ha marcat com a TRUE en els arguments anteriors. És a dir, si en el primer argument una observació ha estat marcada com a TRUE i per tant codificada d'una determinada manera, aquesta observació ja no es tindrà en compte en arguments posteriors encara que en compleixi la condició lògica.

::: {.callout-tip appearance="minimal"}
::: {#exr-catrecode}
## Recodificar categòriques
En els següents exemples treballarem amb una versió reduïda de la [Militarized Interstate Disputes (MID)](https://correlatesofwar.org/data-sets/MIDs){target="_blank"} dataset [@Palmer2020] i de la [World Religion Data (WRD)](https://correlatesofwar.org/data-sets/world-religion-data/){target="_blank"} [@Maoz2013]. T'hauràs de descarregar aquests arxius del següent [enllaç]() i importar-los a R com a `mid_recod` i `relig_recod`.

```{r eval = F}
mid_recod <- read_csv("files/mid_recod.csv")
relig_recod <- read_csv("files/relig_recod.csv")
```

Alternativament, per millorar l'aprenentatge, es recomana anar a la pàgina web de cada base de dades, descarregar la base de dades sencera i el llibre de codis, i treballar amb el marc de dades sencer.
:::
:::

### De vector numèric a categòrica

La [Militarized Interstate Disputes](https://correlatesofwar.org/data-sets/MIDs){target="_blank"} dataset [@Palmer2020] emmagatzema disputes militaritzades entre estats des de 1816 fins a l'actualitat. Moltes de les seves variables venen codificades numèricament, pel qual haurem de consultar el llibre de codis per poder-les convertir al seu valor categòric corresponent. 

::: {.panel-tabset .column-body-outset}

## MID

En la versió reduïda de la MID dataset observem una selecció de disputes militaritzades entre díades de països. Per exemple, en la primera observació veiem la disputa entre França i Rússia que va tenir lloc el 1849. 

```{r}
mid_recod
```

## Períodes

Una recodificació molt habitual és recodificar una variable temporal en dècades o en períodes històrics. Amb el següent codi, hem creat la variable `period` que conté cinc categories.

```{r}
mid_recod$period <- case_when(mid_recod$year < 1914 ~ "Pax Britannica",
                        mid_recod$year < 1946 ~ "The Thirty Years' Crisis",
                        mid_recod$year < 1989 ~ "Cold War",
                        mid_recod$year < 2003 ~ "Post-Cold War",
                        TRUE ~ "Present")
mid_recod
```

## Llibre de codis

Algunes variables ens arriben codificades numèricament, però són en realitat categòriques. Si consultem el llibre de codis de la base de dades (**Dyadic MID 4.02**), veurem que els valors numèrics de `settlmnt` tenen un equivalent categòric.

```{r}
mid_recod$settlmnt <- case_when(mid_recod$settlmnt == 0 ~ "Missing",
                        mid_recod$settlmnt == 1 ~ "Negotiated",
                        mid_recod$settlmnt == 2 ~ "Imposed",
                        mid_recod$settlmnt == 3 ~ "None",
                        mid_recod$settlmnt == 4 ~ "Unclear",
                        TRUE ~ NA_character_)
mid_recod
```


:::


### Recodificar valors categòrics

La [World Religion Data (WRD)](https://correlatesofwar.org/data-sets/world-religion-data/){target="_blank"} [@Maoz2013] conté diversos conjunts de dades sobre l'adherència religiosa en el món des de 1945. Cada conjunt de dades descriu la població que practica cada religió en un nivell diferent: global, regional o estatal. A continuació veurem les dades a nivell global.

::: {.panel-tabset .column-body-outset}

## WRD

En la versió reduïda de la WRD dataset observem un marc de dades amb algunes de les principals religions del món. Per exemple, en la primera observació veiem que la religió Cristianisme protestant (`chrstprot`) tenia 160.887.585 fidels el 1945.

```{r}
relig_recod
```


## Categories

Podem recodificar les religions per crear una nova categoria que englobi les religions majors. Així, les tres religions cristianes que apareixen en la base de dades les codificariem com a Christianism, les jueves com a "Judaism", etc. En primer lloc, mirarem quantes categories tenim.
```{r}
unique(relig_recod$religion)
```

## Religions Majors

Com hem pogut deduir de la pestanya anterior, la millor manera de crear condicions lògiques per aconseguir una variable amb els noms de les religions majors (`mr`) serà amb un `str_detect()`. Com que judaïsme serà difícil d'especificar, hem utilitzat l'expressió regular `^j` que indica que ha de localitzar la lletra "j" a principi de paraula. 

```{r}
relig_recod$mr <- case_when(str_detect(relig_recod$religion, "chrst") ~ "Christianism",
          str_detect(relig_recod$religion, "islm") ~ "Islamism",
          str_detect(relig_recod$religion, "bud") ~ "Buddism",
          str_detect(relig_recod$religion, "^j") ~ "Judaism",
          TRUE ~ "Other/NA")
relig_recod
```
:::



## A variable ordinal

Com s'ha explicat anteriorment, les variables ordinals rarament ens vindran directament codificades com a factor ordinal. El més habitual serà que estiguin codificades com a vector de caràcter o com a vector numèric i que les haguem de recodificar. En aquest apartat veurem com recodificar-les amb la funció `factor()` amb un exemple de cada cas.

```
factor(wb$income_group, 
       ordered = TRUE,
       [levels o labels = ...])
```

Com es pot observar, en el tercer argument s'ha marcat entre claudàtors `levels` o `labels`. Això significa que en funció de la recodificació que busquem farem servir `levels`, `labels` o els dos arguments. L'argument `levels` està pensat per definir l'ordre dels nivells, de menor a major, mentre que l'argument `labels` està pensat per definir les etiquetes de cada nivell. 

::: {.callout-tip appearance="minimal"}
::: {#exr-factorrecode}
## Recodificar factors
En els següents exemples treballarem amb una versió reduïda de la base de dades WB Income Group, accessible a la web del [Banc Mundial](https://blogs.worldbank.org/es/opendata/nueva-clasificacion-de-los-paises-segun-el-nivel-de-ingresos-para-2019-y-2020){target="_blank"}, i de la darrera onada de la [World Values Survey (WVS)](https://www.worldvaluessurvey.org/WVSDocumentationWV7.jsp){target="_blank"}. T'hauràs de descarregar aquests arxius del següent [enllaç] i importar-los a R com a `wb_recod` i `wvs_recod`.

```{r eval = F}
wb_recod <- read_csv("files/wb_recod.csv")
wvs_recod <- read_csv("files/wvs_recod.csv")
```

Alternativament, per millorar l'aprenentatge, es recomana anar a la pàgina web de cada base de dades, descarregar la base de dades sencera i treballar amb el marc de dades sencer. Descarrega també el llibre de codis de la WVS, el _WVS 7 Codebook Variables report.pdf_. 
:::
:::


### De vector de caràcter a ordinal

Una de les variables ordinals més emprades a nivell internacional és la classificació del Banc Mundial segons grup de renda dels països. Aquesta classificació està formada per [quatre categories](https://blogs.worldbank.org/es/opendata/nueva-clasificacion-de-los-paises-segun-el-nivel-de-ingresos-para-2019-y-2020){target="_blank"} (ingrés baix, mitjà-baix, mitjà-alt, alt), que observem a la variable `income_group`. Les categories són de gran importància per a moltes economies en desenvolupament, ja que només les d'ingrés més baix podran accedir a determinats préstecs del Banc. Altres organitzacions internacionals també fan servir aquestes categories. El [Sistema Generalitzat de Preferències](https://policy.trade.ec.europa.eu/development-and-sustainability/generalised-scheme-preferences_en){target="_blank"} de la Unió Europea es basa amb la classificació del Banc Mundial per determinar quins països podran vendre els seus productes al mercat europeu sense haver de pagar aranzels.

::: {.panel-tabset}

## A. WB Income

En la versió reduïda de la base de dades del Banc Mundial, observem que els països estan classificats per regió, grup de renda i tipus de finançament (`lending_category`). Observem com la variable `income_group` està codificada com a vector de caràcter.

```{r}
wb_recod
```


## B. Categories
Per recodificar el vector com a factor ordinal, primer haurem de saber quines són les categories de la variable. Observem que, efectivament, `income_group` és una variable amb quatre categories.

```{r echo = TRUE, collapse=T}
unique(wb_recod$income_group)
```

## C. Factor
Amb la funció `factor()` passem la variable a factor. En el primer argument indiquem el nom del vector, en el segon argument `ordered = TRUE` indiquem que volem ordenar les seves categories i en l'argument `levels` indiquem, de menor a major, l'ordre de les categories.

```{r collapse=T}
wb_recod$income_group <- factor(wb_recod$income_group, 
                                ordered = TRUE,
                                levels = c("Low income", 
                                           "Lower middle income", 
                                           "Upper middle income",
                                           "High income"))
```

## D. Comprovació
Podem comprovar que R ens ha codificat la variable correctament de diverses maneres: 

- Amb la funció `class()` ens apareixerà "ordered" "factor".
- Imprimint el marc de dades ens aparèixerà `<ord>` a sobre de la columna en qüestió. 
- Amb la funció `unique()` veurem l'ordre dels nivells.
- Imprimint el vector també veurem l'ordre dels nivells.

```{r collapse=T}
wb_recod$income_group[1:2]
```
:::

### De vector numèric a ordinal

La majoria de variables ordinals d'enquesta ens arribaran codificades en vectors numèrics, com és el cas de la majoria de variables de l'enquesta [WVS](https://www.worldvaluessurvey.org/WVSDocumentationWV7.jsp){target="_blank"}. Com que les categories ordinals estan codificades numèricament, per recodificar la variable amb els seus valors categòrics haurem de consultar necessàriament el llibre de codis de la base de dades.



::: {.panel-tabset}

## A. WVS

En la versió reduïda de la setena onada de la WVS, observem que els entrevistats, de diversos països, responen a vàries preguntes que són codificades numèricament. Si ens fixem en el llibre de codis de la base de dades, veurem que la variable `Q4` pregunta per la importància que té la política per la persona enquestada. Aquesta pregunta es mesura amb una escala ordinal de quatre valors: 'Molt important' correspon al valor numèric 1, 'Més aviat important' al valor 2, 'No gaire important' al 3 i 'Gens important' al 4.

```{r}
wvs_recod
```


## B. Categories
 Abans de fer la conversió, haurem d'assegurar-nos que aquestes quatre categories estiguin presents a la variable.

```{r collapse=T}
unique(wvs_recod$Q4)
```

Veiem que els quatre valors són presents, així com també el valor `NA`. El valor `NA` respon a les sigles en anglès Not Available (no disponible).

## C1. Labels
Recodificar aquesta variable concreta és un xic contraintuitiu, ja que el nombre 4 correspon al valor més baix de l'escala ordinal (Gens important) mentre que el valor 1 correspon al valor més alt (Molt Important). Això vol dir que haurem d'indicar en algun moment l'ordre correcte dels valors de l'escala. Com que inicialment estem tractant amb un vector numèric, el procediment més senzill serà capgirar l'escala amb una simple resta en el primer argument. En el segon argument indicarem quines són les etiquetes correctes amb `labels` i finalment indicarem que és un factor ordinal en el tercer argument.

```{r eval = T}
wvs_recod$Q4 <- factor(5 - wvs_recod$Q4, 
       labels = c("Not at all important", "Not very important", 
                  "Rather important", "Very important"),
       ordered = T)
```


## C2. Levels
Una segona opció, que dona el mateix resultat que l'anterior, és la següent. En el primer argument indiquem el vector numèric en qüestio. En el segon argument `levels` indiquem l'ordre correcte dels nivells, de menor a major. Amb `labels` indiquem en el tercer argument el nom de les etiquetes que correspondrà a cada nivell i finalment en el quart argument indicarem que és un factor ordinal.

```{r eval = F}
factor(wvs_recod$Q4,
       levels = c("4", "3", "2", "1"),
       labels = c("Not at all important", "Not very important", 
                  "Rather important", "Very important"),
       ordered = T)
```

L'argument `levels` està pensat per definir l'ordre dels nivells, de menor a major, mentre que l'argument `labels` està pensat per definir les etiquetes de cada nivell. 

## D. Comprovació
Podem comprovar que R ens ha codificat la variable correctament de diverses maneres: 

- Amb la funció `class()` ens apareixerà "ordered" "factor".
- Imprimint el marc de dades ens aparèixerà `<ord>` a sobre de la columna en qüestió). 
- Amb la funció `unique()` veurem l'ordre dels nivells.
- Imprimint el vector també veurem l'ordre dels nivells.

```{r collapse=T}
wvs_recod$Q4[1:3]
```
:::

::: {.callout-caution collapse="true"}
## Recodificar moltes variables a la vegada
Si ens fixem en el llibre de codis de la WVS, veurem que moltíssimes variables segueixen la mateixa escala ordinal - sense anar més lluny, les variables de la Q1 a la Q6. Recodificar-les una per una pot ser una feinada. Per sort, més endavant veurem que no cal que fem aquest procediment un a un, sinó que amb vàries funcions del paquet `dplyr` podem recodificar totes les variables de cop amb el mateix codi. A la @tbl-wvs-ordered en veiem l'exemple i el resultat:

```{r eval = FALSE}
wvs_recod |> 
  mutate(across(Q1:Q6, ~ factor(5 - ., 
       labels = c("Not at all important", "Not very important", 
                  "Rather important", "Very important"),
       ordered = T)))
```

```{r echo = FALSE}
#| label: tbl-wvs-ordered
#| tbl-cap: World Values Survey dataset Wave 2017-2020 (v7)
wvs_recod |> 
  select(-Q7, -Q8) |> 
  rename(COWC = C_COW_ALPHA) |> 
  mutate(across(c(Q1:Q3,Q5:Q6), ~ factor(5 - ., 
       labels = c("Not at all important", "Not very important", 
                  "Rather important", "Very important"),
       ordered = T))) |> 
  head(8) |> 
  knitr::kable()
```
:::



## Altres recodificacions

Les recodificacions de variables també es poden fer d'altres maneres. Les opcions més comunes són la funció `recode()` i les funcions `as.xxx()`. 

### Recode

La funció `recode()` del paquet `dplyr` es pot fer servir en qualsevol tipus de variable, però s'acostuma a fer servir en variables categòriques per recodificar individualment qualsevol de les seves categories. És útil quan només hem de modificar unes poques categories. A dins de la funció, introduïm el nom del vector i com a segon argument indiquem el valor que volem recodificar (sense cometes), el símbol `=` i el valor nou (entre cometes).

```
recode(vector, valor_antic = "valor_nou")
```

A continuació veiem dos exemples. 


::: {.panel-tabset}

## Una recodificació

En la recodificació, hem de posar primer el valor que volem recodificar i a continuació, entre cometes, el nou valor.

```{r}
recode(ords$donor, `Turkey-TIKA` = "Turkey-TIK")
```

## Vàries recodificacions

Si volem recodificar varis valors només cal introduir un nou argument amb la mateixa estructura que el segon argument.

```{r}
recode(ratio$country, UKG = "GBR", FRN = "FRA", GMY = "DEU")
```


:::

### Funcions genèriques

També tenim funcions de recodificació genèriques que permeten canviar la classe de vector.

- `as.numeric()`
- `as.factor()`
- `as.character()`
- `as.integer()`
- `as.Date()`

Normalment utilitzarem aquestes funcions quan observem que alguna variable no té la classe de vector que li pertocaria. Per exemple, suposem que quan explorem el marc de dades `polity` ens adonem que tots els vectors són de caràcter.

```{r echo = F}
polity |>
  mutate(across(country:polity2, ~ as.character(.)))
```

En aquest cas, haurem de recodificar les dues últimes variables perquè tinguin el vector numèric.

```{r echo = T, eval = F}
polity$year <- as.numeric(polity$year)
polity$polity2 <- as.numeric(polity$polity2)
```

