---
title: "Dplyr II"
subtitle: "Metodologia Quantitativa I (UPF)"
author: "Jordi Mas Elias"
institute: "<https://www.jordimas.cat/>"
footer: "Metodologia Quantitativa I (UPF)"
logo: logo-upf.png
format: 
  revealjs:
    embed-resources: true
    slide-number: true
    show-slide-number: print
    theme: simple
editor: source
editor_options: 
  chunk_output_type: console
---

## Sumari

- Resumir variables categòriques
- Resumir variables numèriques
- Resumir per grups

# Warm up {background-color="#e8e8e8"}

## R learning curve

```{r}
library(dplyr)
festivals <- readRDS("data/festivals.rds")
lloguer_any <- readRDS("data/lloguer_any.rds")
cens_gc <- readRDS("data/cens_gc.rds")
municipi <- readRDS("data/municipi.rds")
rlc <- tibble(class = 1:8,
             knowledge = (1:8)^3)
class <- 5
plot(rlc$class, rlc$knowledge)
points(rlc$class[class], rlc$knowledge[class], col = "red")
```

## RStudio workflow

**Load packages.**

```{r echo = T, message=F, warning=F}
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
```

![](img/r-packages.png){style="float:center;" width="650"}




# Resumir variables categòriques {background-color="#e8e8e8"}

## Variables categòriques

```{r echo = T, eval = T}
festivals$ambit
```


## Variables categòriques {.scrollable}

**Moda**: El valor més repetit.

- Count: `count(d, v, sort = T)` 

```{r echo = T, eval = T}
count(festivals, ambit, sort = T)
```

- Taula de freqüències: `table(df$v)`

```{r echo = T, eval = T}
table(festivals$ambit)
```

- TF en percentages: `prop.table(table(df$v)) * 100`

```{r echo = T, eval = T}
prop.table(table(festivals$ambit)) * 100
```


- Diagrama de barres: `barplot(table(df$v))`

```{r echo = T, eval = T}
barplot(table(festivals$ambit))
```

- En %: `barplot(prop.table(table(df$v)))`

```{r echo = T, eval = T}
barplot(prop.table(table(festivals$ambit)))
```


```{r eval = F}
table(festivals$ambit)
barplot(table(festivals$ambit))
count(cens_gc, indret_desaparicio)
```


# Resumir variables numèriques {background-color="#e8e8e8"}

## Variables numèriques

Valor central: On es troba el centre?

```{r echo = T, eval = T}
lloguer_any$preu
```



## Variables numèriques

Valor central: On es troba el centre? `median()`, `mean()`.

![](img/uni-mean-median.png)

## Variables numèriques

Valor central: On es troba el centre?

[![](img/gdp-median-nyt.png)](https://www.nytimes.com/2014/09/17/upshot/you-cant-feed-a-family-with-gdp.html)

## Variables numèriques

Valor central: On es troba el centre?

![](img/uni-mean-extreme.png)


## Variables numèriques

Valor central: Moda? `hist(df$v)`.


::: {.panel-tabset}

## As. negativa
```{r}
hist(municipi$altitud_m)
```

## Normal
```{r}
hist(lloguer_any$preu_m2)
```


## As. positiva

```{r}
hist(c(rnorm(1:5, 35, 20), rnorm(1:50, 50, 15), rnorm(1:70, 70, 2)))
```

## Bimodal

```{r}
hist(c(rnorm(1:100, 30, 10), rnorm(1:100, 70, 10)))
```

:::

## Variables numèriques

Notes finals curs 2023

![](img/notesfinals23.png)




## Variables numèriques


Dispersió: Com de dispersos estan els valors?

:::: {.columns}

::: {.column width="60%"}

- Min: `min()`
- Max: `max()`
- Rang: `diff(range())`
- Quantils: `quantile()`
- Rang InterQuartilic: `IQR()`
:::

::: {.column width="35%"}
![](img/uni-dispersion-range.png)
:::

::::


## Variables numèriques {.scrollable}

Dispersió: Com de dispersos estan els valors?

Min: `min()`

```{r echo = T, eval = T}
min(cens_gc$periode_desaparicio_1, na.rm = T)
```

Max: `max()`

```{r echo = T, eval = T}
max(cens_gc$periode_desaparicio_1, na.rm = T)
```

Rang: `diff(range())`

```{r echo = T, eval = T}
diff(range(cens_gc$periode_desaparicio_1, na.rm = T))
```

Quantils: `quantile()`

```{r echo = T, eval = T}
quantile(cens_gc$periode_desaparicio_1, 0.25, na.rm = T)
quantile(cens_gc$periode_desaparicio_1, 0.75, na.rm = T)
```

Rang Interquartílic: `IQR()`

```{r echo = T, eval = T}
IQR(cens_gc$periode_desaparicio_1, na.rm = T)
```




## Variables numèriques

Dispersió: Com de dispersos estan els valors?

- **Desviació estàndard:** Com de lluny respecte la mitjana? `sd()`

![](img/uni-dispersion-sd.png)

## Variables numèriques {.scrollable}

Dispersió: Com de dispersos estan els valors?

- Què és _exactament_ la desviació estàndard? Segueix l'exemple:

A. Tenim un marc de dades, amb dos vectors numèrics.

```{r echo = T, eval = T}
devs <- tibble(vec1 = c(2, 6, 4, 8),
               vec2 = c(1, 9, 3, 7))
```

B. Els dos vectors tenen la mateixa mitjana.

```{r echo = T, eval = T}
mean(devs$vec1)
mean(devs$vec2)
```

C. Però com de lluny estan els valors de la mitjana? Visualment, observem que els valors a `vec2` estan, _de mitjana_, més lluny de la mitjana que els valors de `vec1`. Reprodueix aquest codi al teu ordinador:

```{r echo = T, eval = T}
devs |> 
  pivot_longer(vec1:vec2) |> 
  ggplot(aes(x = name, y = value)) +
  geom_point(aes(col = name), size = 4) +
  stat_summary(geom = "point", size = 4) +
  theme_minimal()
```

D. La desviació estàndard calcula aquesta distància. Encara que no calcula exactament la _mitjana_. El què fa és el següent. Mirem el `vec1`:

- Primer, calcula la distància de cada valor respecte la mitjana.

```{r echo = T, eval = T}
diff <- devs$vec1 - mean(devs$vec1)
diff
```

- Després, eleva les diferències al quadrat (de manera que tots els valors es tornen positius i els valors més alts s'exageren).

```{r echo = T, eval = T}
sq_diff <- diff^2
sq_diff
```

- A continuació, se sumen els valors i el resultat es divideix pel nombre de casos menys ú. Al valor resultant se'n diu **variància**.

```{r echo = T, eval = T}
variance <- sum(sq_diff) / (length(sq_diff) - 1)
variance
```

- La **desviació estàndard** és l'arrel quadrada de la variància.

```{r echo = T, eval = T}
sqrt(variance)
```


E. En resum:

```{r echo = T, eval = T}
devs |> 
  mutate(across(vec1:vec2, ~ . - mean(.))) |> # distance from the mean
  mutate(across(vec1:vec2, ~ .^2)) |> # square all values
  summarize(across(vec1:vec2, ~ sum(.) / (length(.) - 1))) |> #sum and divide number of cases
  mutate(across(vec1:vec2, ~ sqrt(.))) #square root
```


F. O més senzill, amb `sd()`:

```{r echo = T, eval = T}
devs |> 
  summarize(across(vec1:vec2, ~ sd(.)))
```

G. Què passaria si, enlloc de la desviació típica, calculem la distància mitjana respecte la mitjana? Primer calculem la distància absoluta dels valors en cada vector.

```{r echo = T, eval = T, collapse=TRUE}
abs_dist1 <- abs(devs$vec1 - mean(devs$vec1))
abs_dist2 <- abs(devs$vec2 - mean(devs$vec2))
```

I després calculem la mitjana de les distàncies.

```{r echo = T, eval = T, collapse=TRUE}
mean(abs_dist1)
mean(abs_dist2)
```

Com que la desviació estàndard primer eleva els valors al quadrat, els resultats seran majors que no pas si calculem la distància mitjana sobre la mitjana.


# Summarize i group_by functions {background-color="#e8e8e8"}

## Funció summarize

- Resumeix les dades.

```{r echo = T, eval = F}
df |> 
  summarize(name = sum(vector))
```

- Es poden resumir varis elements:

```{r echo = T, eval = F}
df |> 
  summarize(name1 = sum(vector_a),
            name2 = mean(vector_z),
            n = n())
```

*Posar sempre l'argument `na.rm = T`.


## Group_by   

- Sempre es combina amb una altra funció (e.g. `summarize`, `filter`, `mutate`), agrupa les dades pels valors d'un vector^[Aquest vector és normalment un vector de caràcter o un factor, però pot ser també un altre vector amb poques categories (discret).]...

```{r echo = T, eval = F}
df |> 
  group_by(vector) |> 
  summarize(name1 = sum(vector))
```

*Important!!! Amb group_by i summarize, canviem la __unitat d'observació__ del dataset.